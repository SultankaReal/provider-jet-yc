/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConfigAccessObservation struct {
}

type ConfigAccessParameters struct {

	// +kubebuilder:validation:Optional
	DataLens *bool `json:"dataLens,omitempty" tf:"data_lens,omitempty"`

	// +kubebuilder:validation:Optional
	Serverless *bool `json:"serverless,omitempty" tf:"serverless,omitempty"`

	// +kubebuilder:validation:Optional
	WebSQL *bool `json:"webSql,omitempty" tf:"web_sql,omitempty"`
}

type ConfigBackupWindowStartObservation struct {
}

type ConfigBackupWindowStartParameters struct {

	// +kubebuilder:validation:Optional
	Hours *float64 `json:"hours,omitempty" tf:"hours,omitempty"`

	// +kubebuilder:validation:Optional
	Minutes *float64 `json:"minutes,omitempty" tf:"minutes,omitempty"`
}

type ConfigPerformanceDiagnosticsObservation struct {
}

type ConfigPerformanceDiagnosticsParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Required
	SessionsSamplingInterval *float64 `json:"sessionsSamplingInterval" tf:"sessions_sampling_interval,omitempty"`

	// +kubebuilder:validation:Required
	StatementsSamplingInterval *float64 `json:"statementsSamplingInterval" tf:"statements_sampling_interval,omitempty"`
}

type ConfigResourcesObservation struct {
}

type ConfigResourcesParameters struct {

	// +kubebuilder:validation:Required
	DiskSize *float64 `json:"diskSize" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	DiskTypeID *string `json:"diskTypeId,omitempty" tf:"disk_type_id,omitempty"`

	// +kubebuilder:validation:Required
	ResourcePresetID *string `json:"resourcePresetId" tf:"resource_preset_id,omitempty"`
}

type ExtensionObservation struct {
}

type ExtensionParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type PoolerConfigObservation struct {
}

type PoolerConfigParameters struct {

	// +kubebuilder:validation:Optional
	PoolDiscard *bool `json:"poolDiscard,omitempty" tf:"pool_discard,omitempty"`

	// +kubebuilder:validation:Optional
	PoolingMode *string `json:"poolingMode,omitempty" tf:"pooling_mode,omitempty"`
}

type PostgresqlClusterConfigObservation struct {
}

type PostgresqlClusterConfigParameters struct {

	// +kubebuilder:validation:Optional
	Access []ConfigAccessParameters `json:"access,omitempty" tf:"access,omitempty"`

	// +kubebuilder:validation:Optional
	Autofailover *bool `json:"autofailover,omitempty" tf:"autofailover,omitempty"`

	// +kubebuilder:validation:Optional
	BackupRetainPeriodDays *float64 `json:"backupRetainPeriodDays,omitempty" tf:"backup_retain_period_days,omitempty"`

	// +kubebuilder:validation:Optional
	BackupWindowStart []ConfigBackupWindowStartParameters `json:"backupWindowStart,omitempty" tf:"backup_window_start,omitempty"`

	// +kubebuilder:validation:Optional
	PerformanceDiagnostics []ConfigPerformanceDiagnosticsParameters `json:"performanceDiagnostics,omitempty" tf:"performance_diagnostics,omitempty"`

	// +kubebuilder:validation:Optional
	PoolerConfig []PoolerConfigParameters `json:"poolerConfig,omitempty" tf:"pooler_config,omitempty"`

	// +kubebuilder:validation:Optional
	PostgresqlConfig map[string]*string `json:"postgresqlConfig,omitempty" tf:"postgresql_config,omitempty"`

	// +kubebuilder:validation:Required
	Resources []ConfigResourcesParameters `json:"resources" tf:"resources,omitempty"`

	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type PostgresqlClusterDatabaseObservation struct {
}

type PostgresqlClusterDatabaseParameters struct {

	// +kubebuilder:validation:Optional
	Extension []ExtensionParameters `json:"extension,omitempty" tf:"extension,omitempty"`

	// +kubebuilder:validation:Optional
	LcCollate *string `json:"lcCollate,omitempty" tf:"lc_collate,omitempty"`

	// +kubebuilder:validation:Optional
	LcType *string `json:"lcType,omitempty" tf:"lc_type,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Owner *string `json:"owner" tf:"owner,omitempty"`
}

type PostgresqlClusterHostObservation struct {
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	ReplicationSource *string `json:"replicationSource,omitempty" tf:"replication_source,omitempty"`

	Role *string `json:"role,omitempty" tf:"role,omitempty"`
}

type PostgresqlClusterHostParameters struct {

	// +kubebuilder:validation:Optional
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// +kubebuilder:validation:Optional
	ReplicationSourceName *string `json:"replicationSourceName,omitempty" tf:"replication_source_name,omitempty"`

	// +crossplane:generate:reference:type=github.com/yandex-cloud/provider-jet-yc/apis/vpc/v1alpha1.Subnet
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Reference to a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// Selector for a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	Zone *string `json:"zone" tf:"zone,omitempty"`
}

type PostgresqlClusterMaintenanceWindowObservation struct {
}

type PostgresqlClusterMaintenanceWindowParameters struct {

	// +kubebuilder:validation:Optional
	Day *string `json:"day,omitempty" tf:"day,omitempty"`

	// +kubebuilder:validation:Optional
	Hour *float64 `json:"hour,omitempty" tf:"hour,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type PostgresqlClusterObservation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	// +kubebuilder:validation:Required
	Host []PostgresqlClusterHostObservation `json:"host,omitempty" tf:"host,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type PostgresqlClusterParameters struct {

	// +kubebuilder:validation:Required
	Config []PostgresqlClusterConfigParameters `json:"config" tf:"config,omitempty"`

	// +kubebuilder:validation:Optional
	Database []PostgresqlClusterDatabaseParameters `json:"database,omitempty" tf:"database,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	Environment *string `json:"environment" tf:"environment,omitempty"`

	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// +kubebuilder:validation:Required
	Host []PostgresqlClusterHostParameters `json:"host" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	HostGroupIds []*string `json:"hostGroupIds,omitempty" tf:"host_group_ids,omitempty"`

	// +kubebuilder:validation:Optional
	HostMasterName *string `json:"hostMasterName,omitempty" tf:"host_master_name,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	MaintenanceWindow []PostgresqlClusterMaintenanceWindowParameters `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`

	// +crossplane:generate:reference:type=github.com/yandex-cloud/provider-jet-yc/apis/vpc/v1alpha1.Network
	// +kubebuilder:validation:Optional
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// Reference to a Network in vpc to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDRef *v1.Reference `json:"networkIdRef,omitempty" tf:"-"`

	// Selector for a Network in vpc to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDSelector *v1.Selector `json:"networkIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Restore []PostgresqlClusterRestoreParameters `json:"restore,omitempty" tf:"restore,omitempty"`

	// +crossplane:generate:reference:type=github.com/yandex-cloud/provider-jet-yc/apis/vpc/v1alpha1.SecurityGroup
	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// References to SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsRefs []v1.Reference `json:"securityGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsSelector *v1.Selector `json:"securityGroupIdsSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	User []PostgresqlClusterUserParameters `json:"user,omitempty" tf:"user,omitempty"`
}

type PostgresqlClusterRestoreObservation struct {
}

type PostgresqlClusterRestoreParameters struct {

	// +kubebuilder:validation:Required
	BackupID *string `json:"backupId" tf:"backup_id,omitempty"`

	// +kubebuilder:validation:Optional
	Time *string `json:"time,omitempty" tf:"time,omitempty"`

	// +kubebuilder:validation:Optional
	TimeInclusive *bool `json:"timeInclusive,omitempty" tf:"time_inclusive,omitempty"`
}

type PostgresqlClusterUserObservation struct {
}

type PostgresqlClusterUserParameters struct {

	// +kubebuilder:validation:Optional
	ConnLimit *float64 `json:"connLimit,omitempty" tf:"conn_limit,omitempty"`

	// +kubebuilder:validation:Optional
	Grants []*string `json:"grants,omitempty" tf:"grants,omitempty"`

	// +kubebuilder:validation:Optional
	Login *bool `json:"login,omitempty" tf:"login,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Permission []PostgresqlClusterUserPermissionParameters `json:"permission,omitempty" tf:"permission,omitempty"`

	// +kubebuilder:validation:Optional
	Settings map[string]*string `json:"settings,omitempty" tf:"settings,omitempty"`
}

type PostgresqlClusterUserPermissionObservation struct {
}

type PostgresqlClusterUserPermissionParameters struct {

	// +kubebuilder:validation:Required
	DatabaseName *string `json:"databaseName" tf:"database_name,omitempty"`
}

// PostgresqlClusterSpec defines the desired state of PostgresqlCluster
type PostgresqlClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PostgresqlClusterParameters `json:"forProvider"`
}

// PostgresqlClusterStatus defines the observed state of PostgresqlCluster.
type PostgresqlClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PostgresqlClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// PostgresqlCluster is the Schema for the PostgresqlClusters API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type PostgresqlCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              PostgresqlClusterSpec   `json:"spec"`
	Status            PostgresqlClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PostgresqlClusterList contains a list of PostgresqlClusters
type PostgresqlClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []PostgresqlCluster `json:"items"`
}

// Repository type metadata.
var (
	PostgresqlCluster_Kind             = "PostgresqlCluster"
	PostgresqlCluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: PostgresqlCluster_Kind}.String()
	PostgresqlCluster_KindAPIVersion   = PostgresqlCluster_Kind + "." + CRDGroupVersion.String()
	PostgresqlCluster_GroupVersionKind = CRDGroupVersion.WithKind(PostgresqlCluster_Kind)
)

func init() {
	SchemeBuilder.Register(&PostgresqlCluster{}, &PostgresqlClusterList{})
}
